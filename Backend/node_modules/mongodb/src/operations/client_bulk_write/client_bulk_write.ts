import { BSON, type Document } from '../../bson';
import { DocumentSequence } from '../../cmap/commands';
import { MongoAPIError, MongoInvalidArgumentError } from '../../error';
import { type PkFactory } from '../../mongo_client';
import type { Filter, OptionalId, UpdateFilter, WithoutId } from '../../mongo_types';
import { DEFAULT_PK_FACTORY, hasAtomicOperators } from '../../utils';
import { type CollationOptions } from '../command';
import { type Hint } from '../operation';
import type {
  AnyClientBulkWriteModel,
  ClientBulkWriteOptions,
  ClientDeleteManyModel,
  ClientDeleteOneModel,
  ClientInsertOneModel,
  ClientReplaceOneModel,
  ClientUpdateManyModel,
  ClientUpdateOneModel
} from './common';

/** @internal */
export interface ClientBulkWriteCommand {
  bulkWrite: 1;
  errorsOnly: boolean;
  ordered: boolean;
  ops: DocumentSequence;
  nsInfo: DocumentSequence;
  bypassDocumentValidation?: boolean;
  let?: Document;
  comment?: any;
}

/**
 * The bytes overhead for the extra fields added post command generation.
 */
const MESSAGE_OVERHEAD_BYTES = 1000;

/** @internal */
export class ClientBulkWriteCommandBuilder {
  models: ReadonlyArray<AnyClientBulkWriteModel<Document>>;
  options: ClientBulkWriteOptions;
  pkFactory: PkFactory;
  /** The current index in the models array that is being processed. */
  currentModelIndex: number;
  /** The model index that the builder was on when it finished the previous batch. Used for resets when retrying. */
  previousModelIndex: number;
  /** The last array of operations that were created. Used by the results merger for indexing results. */
  lastOperations: Document[];
  /** Returns true if the current batch being created has no multi-updates. */
  isBatchRetryable: boolean;

  /**
   * Create the command builder.
   * @param models - The client write models.
   */
  constructor(
    models: ReadonlyArray<AnyClientBulkWriteModel<Document>>,
    options: ClientBulkWriteOptions,
    pkFactory?: PkFactory
  ) {
    this.models = models;
    this.options = options;
    this.pkFactory = pkFactory ?? DEFAULT_PK_FACTORY;
    this.currentModelIndex = 0;
    this.previousModelIndex = 0;
    this.lastOperations = [];
    this.isBatchRetryable = true;
  }

  /**
   * Gets the errorsOnly value for the command, which is the inverse of the
   * user provided verboseResults option. Defaults to true.
   */
  get errorsOnly(): boolean {
    if ('verboseResults' in this.options) {
      return !this.options.verboseResults;
    }
    return true;
  }

  /**
   * Determines if there is another batch to process.
   * @returns True if not all batches have been built.
   */
  hasNextBatch(): boolean {
    return this.currentModelIndex < this.models.length;
  }

  /**
   * When we need to retry a command we need to set the current
   * model index back to its previous value.
   */
  resetBatch(): boolean {
    this.currentModelIndex = this.previousModelIndex;
    return true;
  }

  /**
   * Build a single batch of a client bulk write command.
   * @param maxMessageSizeBytes - The max message size in bytes.
   * @param maxWriteBatchSize - The max write batch size.
   * @returns The client bulk write command.
   */
  buildBatch(
    maxMessageSizeBytes: number,
    maxWriteBatchSize: number,
    maxBsonObjectSize: number
  ): ClientBulkWriteCommand {
    // We start by assuming the batch has no multi-updates, so it is retryable
    // until we find them.
    this.isBatchRetryable = true;
    let commandLength = 0;
    let currentNamespaceIndex = 0;
    const command: ClientBulkWriteCommand = this.baseCommand();
    const namespaces = new Map<string, number>();
    // In the case of retries we need to mark where we started this batch.
    this.previousModelIndex = this.currentModelIndex;

    while (this.currentModelIndex < this.models.length) {
      const model = this.models[this.currentModelIndex];
      const ns = model.namespace;
      const nsIndex = namespaces.get(ns);

      // Multi updates are not retryable.
      if (model.